/*********************************************************************
*                                                                    *
* This file is posted by Dr. Stevan Gavrilovic (steva44@hotmail.com) *
* as a result of work performed in the research group of Professor   *
* Terje Haukaas (terje@civil.ubc.ca) at the University of British    *
* Columbia in Vancouver. The code is part of the computer program    *
* Rts, which is an extension of the computer program Rt developed by *
* Dr. Mojtaba Mahsuli (mahsuli@sharif.edu) in the same group.        *
*                                                                    *
* The content of this file is the product of thesis-related work     *
* performed at the University of British Columbia (UBC). Therefore,  *
* the Rights and Ownership are held by UBC.                          *
*                                                                    *
* Please be cautious when using this code. It is provided “as is”    *
* without warranty of any kind, express or implied.                  *
*                                                                    *
* Contributors to this file:                                         *
*   - Mojtaba Mahsuli                                                *
*   - Terje Haukaas                                                  *
*   - Stevan Gavrilovic                                              *
*   - Rodrigo Costa                                                  *
*                                                                    *
*********************************************************************/

#include "RObject.h"
#include "RModel.h"
#include "RLocation.h"
#include "RLocationResponse.h"
#include "RTimeSeries.h"
#include "RTimeSeriesResponse.h"
#include "RMainWindow.h"
#ifdef DETAILEDBUILDINGS
#include "RComponent.h"
#endif
#ifdef OPENSEES
#include "Domain.h"
#endif
#ifdef NETWORKS
#include "RRoute.h"
#include "RPacket.h"
#include "RPacketResponse.h"
#endif

#include <QMetaProperty>
#include <QEvent>
#include <QDynamicPropertyChangeEvent>

RObject::RObject(QObject *parent, QString name)
    : QObject(parent)
{
    theDomain = qobject_cast<RDomain*>(parent);

    setObjectName(name);

    theAutoGenerated = true;

    theOutputLevel = RObject::Medium;

    theGradientType = RGradientType::NONE;

    objectTag = -1;
}


RObject::~RObject()
{

}


bool RObject::isAutoGenerated()
{
    return theAutoGenerated;
}


void RObject::setAutoGenerated(bool autoGenerated)
{
    theAutoGenerated = autoGenerated;
}


RObject::ROutputLevelType RObject::getOutputLevel()
{
    return theOutputLevel;
}


void RObject::setOutputLevel(RObject::ROutputLevelType value)
{
    theOutputLevel = value;
}


int RObject::generateOpenSeesInput(std::string& object, int flag)
{
    qCritical()<<"OpenSees export not implemented in "<<this->objectName();

    return -1;
}


void RObject::setObjectName(const QString &name)
{
    QObject *object = qobject_cast<QObject *>(this);
    object->setObjectName(name);
}


int RObject::checkProperties()
{
    // Looping over QProperties
    for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
        // Getting the meta property
        QMetaProperty metaProperty = this->metaObject()->property(i);
        QVariant::Type type = metaProperty.type();
        const char * charName = metaProperty.name();

        // Checking if the type of the property is "QObject *"
        if (type == QMetaType::QObjectStar) {
            // Getting the vaue of the property, which is a "QObject *"
            QObject *propertyObject = this->property(charName).value<QObject *>();
            if (!propertyObject) {
                qCritical() << "Warning in object" << objectName() << ": The property" << QString(charName) << "is empty.";
                //return -1;
            }
        }
    }
    return 0;
}


double RObject::getDoubleParameter(double *value, RParameter *valueParameter)
{
    if (valueParameter) {
        *value = valueParameter->getCurrentValue();
    }
    return *value;
}


QString RObject::getStringParameter(double *value, RParameter *valueParameter)
{
    QString result;
    if (valueParameter) {
        *value = valueParameter->getCurrentValue();
        result = valueParameter->objectName();
    } else {

        // Is this enough precision?
        result = QString("%1").arg(*value, 0, 'g', 13);
    }
    return result;
}


void RObject::setStringParameter(QString valueStr, double *value, QPointer<RParameter> *valueParameter)
{
    bool ok;
    double temp;
    if (valueStr.isEmpty()) {
        temp = 0.0;
        ok = true;
    } else {
        temp = valueStr.toDouble(&ok);
    }
    if (!ok) {
        if (!theDomain) {
            qCritical() << "ATTENTION: The parent of the object" << objectName() << "is not in the domain.";
        }
        RParameter *tempParameter = theDomain->findChild<RParameter *>(valueStr);
        if (tempParameter) {

            if(!valueParameter->isNull())
                theDomain->deleteObject(valueParameter->data()->objectName());

            *valueParameter = tempParameter;
            *value = tempParameter->getCurrentValue();
        } else {
            if (!valueStr.isEmpty()) {
                qCritical() << "Error: Could not find a parameter named" << valueStr << "in the domain. Reverting back to the previous value.";
            }
        }
    } else
    {

        if(!valueParameter->isNull())
        {
           valueParameter->data()->setCurrentValue(temp);
        }
        else
        {
        *valueParameter = nullptr;
        *value = temp;
        }
    }
}


QString RObject::parameterListToString(QList<QPointer<RParameter> > passedList)
{
    QString string;
    for (int i = 0; i < passedList.count(); i++) {
        if (passedList[i]) {
            string += passedList[i]->objectName();
            string += "; ";
        } else {
            passedList.removeAt(i);
            i--;
        }
    }
    return string;
}


#ifdef DETAILEDBUILDINGS
QString RObject::componentListToString(QList<QPointer<RComponent> > passedList)
{
    QString string;
    for (int i = 0; i < passedList.count(); i++) {
        if (passedList[i]) {
            string += passedList[i]->objectName();
            string += "; ";
        } else {
            passedList.removeAt(i);
            i--;
        }
    }
    return string;
}
#endif


QString RObject::modelListToString(QList<QPointer<RModel> > passedList)
{
    QString string;
    for (int i = 0; i < passedList.count(); i++) {
        if (passedList[i]) {
            string += passedList[i]->objectName();
            string += "; ";
        } else {
            passedList.removeAt(i);
            i--;
        }
    }
    return string;
}


QString RObject::translateGradientTypeToString()
{
    if (theGradientType == RGradientType::FDM) {
        return QString("Finite difference");
    }
    else if (theGradientType == RGradientType::DDM) {
        return QString("Direct differentiation");
    }
    else if (theGradientType == RGradientType::D2DM) {
        return QString("Second-order direct differentiation");
    } else {
        return QString("No gradient method is set");
    }
}


void RObject::setGradientTypeInRObject(QString value)
{
    // This should be changed and extended:
    // First-order DDM: DDM1
    // Second-order DDM: DDM2
    // Third-order DDM: DDM3
    // First-order FDM: FDM1
    // Second-order FDM: FDM2
    // Third-order FDM: FDM3
    if (value.toLower().startsWith("finite") || value.toLower().startsWith("fdm")) {
        theGradientType = RGradientType::FDM;
    }
    else if (value.toLower().startsWith("direct") || value.toLower().startsWith("ddm")) {
        theGradientType = RGradientType::DDM;
    }
    else if (value.contains("D2DM")) {
        theGradientType = RGradientType::D2DM;
    }
    else {
        qCritical() << this->objectName() << "has problems understanding the gradient method.";
    }
}


QList<QPointer<RParameter> > RObject::stringToParameterList(QString passedString)
{
    QList<QPointer<RParameter> > objectList;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";

    for (int i = 0; i < stringList.count(); i++) {
        RParameter *object = theDomain->findChild<RParameter *>(stringList[i]);
        if (object) {
            objectList.append(object);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not find a parameter named" << stringList[i] << "in the domain";
        }
    }

    return objectList;
}


#ifdef DETAILEDBUILDINGS
QList<QPointer<RComponent> > RObject::stringToComponentList(QString passedString)
{
    QList<QPointer<RComponent> > objectList;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";

    for (int i = 0; i < stringList.count(); i++) {
        RComponent *object = theDomain->findChild<RComponent *>(stringList[i]);
        if (object) {
            objectList.append(object);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not find a component named" << stringList[i] << "in the domain";
        }
    }

    return objectList;
}
#endif


QList<QPointer<RModel> > RObject::stringToModelList(QString passedString)
{
    QList<QPointer<RModel> > objectList;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";

    for (int i = 0; i < stringList.count(); i++) {
        RModel *object = theDomain->findChild<RModel *>(stringList[i]);
        if (object) {
            objectList.append(object);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not find a model named" << stringList[i] << "in the domain";
        }
    }

    return objectList;
}


QString RObject::intVectorToString(QVector<int> passedVector)
{
    QString result;
    for (int i = 0; i < passedVector.count(); i++) {
        result += QString("%1; ").arg(passedVector[i]);
    }
    return result;
}


QVector<int> RObject::stringToIntVector(QString passedString)
{
    QVector<int> resultVector;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";
    for (int i = 0; i < stringList.count(); i++) {
        bool ok = false;
        int temp = stringList[i].toInt(&ok);
        if (ok) {
            resultVector.append(temp);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not convert" << stringList[i] << "to an integer.";
        }
    }

    return resultVector;
}


QString RObject::doubleVectorToString(QVector<double> passedVector)
{
    QString result;
    for (int i = 0; i < passedVector.count(); i++) {
        result += QString("%1; ").arg(passedVector[i], 0, 'g', 15);
    }
    return result;
}


QVector<double> RObject::stringToDoubleVector(QString passedString)
{
    QVector<double> resultVector;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";
    for (int i = 0; i < stringList.count(); i++) {
        bool ok = false;
        double temp = stringList[i].toDouble(&ok);
        if (ok) {
            resultVector.append(temp);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not convert" << stringList[i] << "to a double precision real number.";
        }
    }

    return resultVector;
}


RLocation * RObject::parameterToLocation(RParameter *parameter)
{
    RLocation *Location = qobject_cast<RLocation *>(parameter);
    if (Location) {
        return Location;
    }
    RLocationResponse *LocationResponse = qobject_cast<RLocationResponse *>(parameter);
    if (LocationResponse) {
        Location = qobject_cast<RLocation *>(LocationResponse->getLocation());
        if (Location) {
            return Location;
        } else {
            qCritical() << "Warning: The Location response" << LocationResponse->objectName() << "does not include any Location object.";
            return nullptr;
        }
    }
    if (parameter) {
        qCritical() << "Warning: The parameter" << parameter->objectName() << "is not a Location or Location response object.";
    }
    return nullptr;
}


RTimeSeries * RObject::parameterToTimeSeries(RParameter *parameter)
{
    RTimeSeries *TimeSeries = qobject_cast<RTimeSeries *>(parameter);
    if (TimeSeries) {
        return TimeSeries;
    }
    RTimeSeriesResponse *TimeSeriesResponse = qobject_cast<RTimeSeriesResponse *>(parameter);
    if (TimeSeriesResponse) {
        TimeSeries = TimeSeriesResponse->getTimeSeries();
        if (TimeSeries) {
            return TimeSeries;
        } else {
            qCritical() << "Warning: The TimeSeries response" << TimeSeriesResponse->objectName() << "does not include any TimeSeries object.";
            return nullptr;
        }
    }
    if (parameter) {
        qCritical() << "Warning: The parameter" << parameter->objectName() << "is not a TimeSeries or TimeSeries response object.";
    }
    return nullptr;
}


QList<RLocation *> RObject::parameterListToLocationList(QList<QPointer<RParameter> > parameterList, bool checkForDuplicates)
{
    QList<RLocation *> LocationList;
    for (int i = 0; i < parameterList.count(); i++) {
        if (parameterList[i]) {
            RLocation *Location = parameterToLocation(parameterList[i]);
            if (Location) {
                LocationList << Location;
            }
        }
    }

    if (checkForDuplicates) {
        for (int i = 0; i < LocationList.count(); i++) {
            for (int j = i + 1; j < LocationList.count(); j++) {
                if (LocationList[i]->getLatitude() == LocationList[j]->getLatitude() && LocationList[i]->getLongitude() == LocationList[j]->getLongitude()) {
                    if (!RMainWindow::noWarning) {
                        qCritical() << "Warning: The Locations" << LocationList[i]->objectName() << "and" << LocationList[j]->objectName() << "entered in object" << objectName() << "have identical coordinates. This can result in unpredictable errors.";
                    }
                }
            }
        }
    }

    return LocationList;
}


bool RObject::event(QEvent *e)
{
    if (e->type() == QEvent::DynamicPropertyChange) {
        QDynamicPropertyChangeEvent *changeEvent = static_cast<QDynamicPropertyChangeEvent *>(e);
        const char *propertyNameChar = changeEvent->propertyName().constData();
        QString propertyName = QString(propertyNameChar);
        QVariant propertyValue = this->property(propertyNameChar);
        if (propertyValue != QVariant()) {
            setDynamicProperty(propertyName, propertyValue);
        }
        return true;
    } else {
        return QObject::event(e);
    }
}


int RObject::getObjectTag() const
{
    return objectTag;
}


void RObject::setObjectTag(int value)
{
    objectTag = value;
}


void RObject::setDynamicProperty(QString propertyName, QVariant propertyValue)
{
    return;
}


QStringList RObject::getActionList()
{
    // This is a default method only in case some subclasses do not implement it
    return QStringList();
}


void RObject::help()
{
    qDebug() << "*****************************************************************";
    qDebug() << "You asked for help on" << this->objectName() << "but";
    qDebug() << "the developer has not yet implemented the help method for this class.";
    qDebug() << "*****************************************************************";
}


#ifdef OPENSEES
Domain* RObject::getTheOpenSeesDomain()
{
    if(theDomain)
        return theDomain->getTheOpenSeesDomain();

    return nullptr;
}
#endif


#ifdef NETWORKS
//***********Rodrigo's changes
RRoute * RObject::parameterToRoute(RParameter *parameter)
{
    RRoute *Route = qobject_cast<RRoute *>(parameter);
    if (Route) {
        return Route;
    }

    /*
    RLocationResponse *LocationResponse = qobject_cast<RLocationResponse *>(parameter);
    if (LocationResponse) {
        Location = qobject_cast<RLocation *>(LocationResponse->getLocation());
        if (Location) {
            return Location;
        } else {
            qCritical() << "Warning: The Location response" << LocationResponse->objectName() << "does not include any Location object.";
            return 0;
        }
    }
    if (parameter) {
        qCritical() << "Warning: The parameter" << parameter->objectName() << "is not a Location or Location response object.";
    }
    */
    return 0;
}


QList<RRoute *> RObject::parameterListToRouteList(QList<QPointer<RParameter> > parameterList)
{
    QList<RRoute *> RouteList;
    for (int i = 0; i < parameterList.count(); i++) {
        if (parameterList[i]) {
            RRoute *Route = parameterToRoute(parameterList[i]);
            if (Route) {
                RouteList << Route;
            }
        }
    }

    return RouteList;
}
//***********Rodrigo's changes

QString RObject::packetListToString(QList<QPointer<RPacket> > passedList)
{
    QString string;
    for (int i = 0; i < passedList.count(); i++) {
        if (passedList[i]) {
            string += passedList[i]->objectName();
            string += "; ";
        } else {
            passedList.removeAt(i);
            i--;
        }
    }
    return string;
}



QList<QPointer<RPacket> > RObject::stringToPacketList(QString passedString)
{
    QList<QPointer<RPacket> > objectList;
    QString string = passedString;

    QRegExp regExp = QRegExp(QString("[ ,;:\t\n\v\r%1%2]").arg(QChar(QChar::ParagraphSeparator)).arg(QChar(QChar::LineSeparator)));
    QStringList stringList = string.split(regExp, QString::SkipEmptyParts);
    string = "";
    RDomain *theDomain = qobject_cast<RDomain *>(parent());
    for (int i = 0; i < stringList.count(); i++) {
        RPacket *object = theDomain->findChild<RPacket *>(stringList[i]);
        if (object) {
            objectList.append(object);
        } else {
            qCritical() << "Error in" << objectName() << ": Could not find a packet named" << stringList[i] << "in the domain";
        }
    }

    return objectList;
}


RPacket * RObject::parameterToPacket(RParameter *parameter)
{
    RPacket *Packet = qobject_cast<RPacket *>(parameter);
    if (Packet) {
        return Packet;
    }
    RPacketResponse *PacketResponse = qobject_cast<RPacketResponse *>(parameter);
    if (PacketResponse) {
        Packet = qobject_cast<RPacket *>(PacketResponse->getPacket());
        if (Packet) {
            return Packet;
        } else {
            qCritical() << "Warning: The Packet response" << PacketResponse->objectName() << "does not include any Packet object.";
            return 0;
        }
    }
    if (parameter) {
        qCritical() << "Warning: The parameter" << parameter->objectName() << "is not a Packet or Packet response object.";
    }
    return 0;
}


QList<RPacket *> RObject::parameterListToPacketList(QList<QPointer<RParameter> > parameterList)
{
    QList<RPacket *> PacketList;
    for (int i = 0; i < parameterList.count(); i++) {
        if (parameterList[i]) {
            RPacket *Packet = parameterToPacket(parameterList[i]);
            if (Packet) {
                PacketList << Packet;
            }
        }
    }

    return PacketList;
}
#endif

