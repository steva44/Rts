#ifndef RDomain_H
#define RDomain_H
/*********************************************************************
*                                                                    *
* This file is posted by Dr. Stevan Gavrilovic (steva44@hotmail.com) *
* as a result of work performed in the research group of Professor   *
* Terje Haukaas (terje@civil.ubc.ca) at the University of British    *
* Columbia in Vancouver. The code is part of the computer program    *
* Rts, which is an extension of the computer program Rt developed by *
* Dr. Mojtaba Mahsuli (mahsuli@sharif.edu) in the same group.        *
*                                                                    *
* The content of this file is the product of thesis-related work     *
* performed at the University of British Columbia (UBC). Therefore,  *
* the Rights and Ownership are held by UBC.                          *
*                                                                    *
* Please be cautious when using this code. It is provided “as is”    *
* without warranty of any kind, express or implied.                  *
*                                                                    *
* Contributors to this file:                                         *
*   - Mojtaba Mahsuli                                                *
*   - Stevan Gavrilovic                                              *
*   - Terje Haukaas                                                  *
*                                                                    *
*********************************************************************/

#include "RTime.h"
#include "RObject.h"
#include "RConstant.h"

#include <functional>
#include <algorithm>
#include <memory>
#include <unordered_map>

#ifdef OPENSEES
#include "Domain.h"
#include <sstream>
#endif

class RModel;
class RParameter;
class RRandomVariable;
class RDecisionVariable;
class RResponse;
class RConstant;
class RTime;
#ifdef DETAILEDBUILDINGS
class RStatistics;
extern RConstant* theGlobalMeshOption;
#endif

extern RTime* theCurrentTime;

struct RGetObjects
{
public:

    template <typename From, typename To>
    struct static_caster
    {
        To* operator()(From* p) {return static_cast<To*>(p);}
    };

    template <typename T>
    void registerClasstoGet(std::string const &type)
    {
        getObjectRegistry()[type] = [](QObject* parent){

            std::list<RObject*> returnList;

            std::list<T*> list = parent->findChildren<T*>().toStdList();

            //Since the list is in terms of the derived class, we need to cast to parent RObject
            std::transform(list.begin(), list.end(), std::back_inserter(returnList), static_caster<T,RObject>());

            return returnList;
        };
    }


   std::list<RObject*> getObjectList(std::string const &type, QObject* parent)
   {
       std::list<RObject*> list;

       auto it = getObjectRegistry().find(type);
       if (it == getObjectRegistry().end())
       {
           // Return an empty list
           return list;
       }

       list = it->second(parent);

       return list;
   }

private:

   // Map to hold the get object class type, templated alias; cannot template a typedef
   using getObjectTypeMap = std::unordered_map<std::string, std::function<std::list<RObject*>(QObject*)>> ;
   static getObjectTypeMap & getObjectRegistry()
   {
       static getObjectTypeMap mapVal;
       return mapVal;
   }


};

// Factory class using variadic templates and lambda functions to keep it reuseable and general
template <typename T>
class RFactory
{
public:

    RGetObjects getObjects; //Specific for RDomain

    template <typename... TDerived>

    static  T* instantiate(std::string const &type, TDerived&&...args)
    {
        auto it = registry().find(type);
        if (it == registry().end())
        {
            return 0;
        }

        return it->second(args...);
    }

    // Function to register the class
    template <typename TDerived>
    int registerClass(std::string type)
    {
         registry()[type] = [](QObject* parent, QString name){return new TDerived(parent, name);};

         getObjects.registerClasstoGet<TDerived>(type); //Specific for RDomain

         return 0;
    }

private:

    // Map to hold the create object class types
    typedef std::unordered_map<std::string, std::function<T*(QObject*, QString)>> registryMap;

    static registryMap & registry()
    {
        static registryMap mapVal;
        return mapVal;
    }
};


class RDomain : public RObject
{
	Q_OBJECT

public:
	RDomain(QObject *parent, QString name);
	~RDomain();

	// Creates a new RObject given its object name, and class name
	int createObject(QString name, QString passedClassName, bool isAutoGenerated = true);

	// Deletes an RObject given its name
	int deleteObject(QString name);

	// Renames an RObject after checking if the name complies with the naming rules
	int renameObject(QObject *passedObject, QString name);

	// Returns a pointer to the last instantiated RObject 
	QObject *getLastAddedObject() const;

	// Checks if a given object name compies with the naming rules
	int nameIsValid(QString name, bool checkForDuplicate = true);

	// Sets a flag that indicates if Rt is currently in the process of opening an input file
	void setInputFileBeingOpened(bool value);

	// Returns a list of RObject pointer that are derived from the passed class name
	QObjectList getObjectList(QString passedClassName);

	// Returns a string-list of object names from the passed list of object pointers
	QStringList getStringList(QObjectList objectList);

	// Returns the value of a meta-property named "propertyName" for the passed object as a string
	QString getProperty(const QObject *passedObject, QString propertyName) const;

	// Sets the value of a meta-property named "propertyName" for the passed object to the passed value
	int setProperty(QObject *passedObject, QString propertyName, QString propertyValue);

	// Retunrs the current file path of Rt
	QString getCurrentFilePath() const;

	// Sets the current file path of Rt to the passed value
	void setCurrentFilePath(QString value);

    // Sorts the passed QObject list by their object names
	int sort(QObjectList *passedList);

	// Overload method that sorts the passed model list by their object names
	int sort(QList<RModel *> *passedList);

	// Overload method that sorts the passed parameter list by their object names
	int sort(QList<RParameter *> *passedList);

	// Overload method that sorts the passed rv list according to a sorting measure, which can be Name, Alpha, or Gamma
	int sort(QList<RRandomVariable *> *passedList, QString sortingMeasure = QString("Name"));

	// Overload method that sorts the passed dv list according to a sorting measure, which can be Name or Sensitivity
	int sort(QList<RDecisionVariable *> *passedList, QString sortingMeasure = QString("Name"));

	// Overload method that sorts the passed constant list by their object names
	int sort(QList<RConstant *> *passedList);

	// Overload method that sorts the passed response list by their object names
	int sort(QList<RResponse *> *passedList);

	// Returns a list of possible values for the passed property that the user can choose from
	QStringList getPropertyStringList(QString propertyName);

	// Prints the elements of the passed matrix to the output pane, or to the passed outputFile if any
    void print(QVector< QVector<double> > *matrix, QString outputFile = QString());

	// Overloaded method that print the elements of the passed vector to the output pane, or to the passed outputFile if any
    void print(QVector<double> *vector, QString outputFile = QString());

	// Reads the elements of the passed matrix from the inputFile
    int readMatrixFromFile(QVector< QVector<double> > *matrix, QString inputFile);
	
	// Overloaded method that reads the elements of the passed matrix from the inputFile
    int readVectorFromFile(QVector<double> *vector, QString inputFile);

	// Static method that returns the sub-branches of a base-class to be shown in the object pane tree
    static QStringList createObjectTreeBranches(QString baseClassType);

    // Static method that returns the name of all dynamic meta-properties in any class in Rt
	static QStringList getDynamicPropertyList();

	// Static method that returns the absolute path to the folder that contains the passed file
	static QString getAbsoluteFolderPath(QString filePath);

	// Static method that returns the file name of the passed file
	static QString getFileName(QString filePath);

	// Static method that coverts the passed string to a file path, by removing the double-quotes from the string
	static QString stringToFilePath(QString string);

    void clearAnalyzedFlags();

    int checkAllProperties();

    void addToDDMList(RParameter* theParameter);

    QList<RParameter*> getDDMParameterList();

    void updateObjectTree();

#ifdef DETAILEDBUILDINGS
    RStatistics* getStatsMethod(void);
#endif

#ifdef OPENSEES
    Domain *getTheOpenSeesDomain() const;
    void setTheOpenSeesDomain(Domain *value);
#endif

private:

    // Define instance of factory class to create classes dynamically
    RFactory<RObject> factory;

    // Pointer to the last instantiated rObject
	QObject *theLastAddedObject;

    // Data member that stores the current file path of Rt
    QString theCurrentFilePath;

	// Flag that indicates if Rt is currently in the process of opening an input file
	bool isInputFileBeingOpened;

    // List that DDM will be performed on.
    QList<RParameter*> theDomainDDMParameterList;

    void registerHeadersAsClasses();

    int idTag;

#ifdef DETAILEDBUILDINGS
    std::unique_ptr<RStatistics> theStatsMethod;
#endif

#ifdef OPENSEES
    Domain* theOpenSeesDomain;
#endif

};




#endif // RDomain_H
