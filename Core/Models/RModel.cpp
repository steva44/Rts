/*********************************************************************
*                                                                    *
* This file is posted by Dr. Stevan Gavrilovic (steva44@hotmail.com) *
* as a result of work performed in the research group of Professor   *
* Terje Haukaas (terje@civil.ubc.ca) at the University of British    *
* Columbia in Vancouver. The code is part of the computer program    *
* Rts, which is an extension of the computer program Rt developed by *
* Dr. Mojtaba Mahsuli (mahsuli@sharif.edu) in the same group.        *
*                                                                    *
* The content of this file is the product of thesis-related work     *
* performed at the University of British Columbia (UBC). Therefore,  *
* the Rights and Ownership are held by UBC.                          *
*                                                                    *
* Please be cautious when using this code. It is provided “as is”    *
* without warranty of any kind, express or implied.                  *
*                                                                    *
* Contributors to this file:                                         *
*   - Mojtaba Mahsuli                                                *
*   - Terje Haukaas                                                  *
*   - Stevan Gavrilovic                                              *
*                                                                    *
*********************************************************************/

#include "RModel.h"
#include "RParameter.h"
#include "RRandomVariable.h"
#include "RDecisionVariable.h"
#include "RContinuousDecisionVariable.h"
#include "RConstant.h"
#include "RResponse.h"
#include "RFileResponse.h"
#include "RLocation.h"
#include "RLocationResponse.h"
#include "RLinearSolver.h"
#include "RMainWindow.h"
#ifdef NETWORKS
#include "RNetworkModel.h"
#endif

#include <QDir>
#include <QApplication>
#include <QMetaProperty>
#include <QTimer>
#include <QDateTime>

RModel::RModel(QObject *parent, QString name)
    : RObject(parent, name)
{
    isOrchestratingModel = false;
    processFinishedAnalyzing = false;
    isAnalyzed = false;

    theProcess = 0;
}


RModel::~RModel()
{
    delete theProcess;
}


QList<QPair<double, QString> > RModel::getTriggerTimes(double startTime, double endTime)
{
    QList<QPair<double, QString> > times;

    return times;
}


void RModel::setObjectName(const QString &name)
{
    QString oldName = objectName();
    QObject *object = qobject_cast<QObject *>(this);
    object->setObjectName(name);

    // Renaming auto-generated responses
    QList<RResponse *> responseList = findChildren<RResponse *>();
    for (int i = 0; i < responseList.count(); i++) {
        if (responseList[i]->isAutoGenerated()) {
            QString responseName = responseList[i]->objectName();
            if (responseName.contains(oldName)) {
                QString newResponseName = responseName.replace(oldName, name);
                responseList[i]->setObjectName(newResponseName);
            }
        }
    }


    // Terje split the parameters into a separate area in the object's pane, hence that area must also be updated:
    RMainWindow *mainWindow = qobject_cast<RMainWindow *>(theDomain->parent());
    mainWindow->updateTree("Parameters");
}


QStringList RModel::getActionList()
{
    QStringList actionList;

    actionList << "&Run" << "Separator" << "&Help";

    return actionList;
}


void RModel::run()
{   
//    if (checkProperties() >= 0) {

        if (isOrchestratingModel) {

            //  START TIMER
            QDateTime startTime = QDateTime::currentDateTime();

            // TELL USER WE'RE STARTING
            if (theOutputLevel == RObject::Maximum) {
                //qDebug() << "The analysis in" << this->objectName() << "started";
            }


            // KEEP GUI RESPONSIVE
            QCoreApplication::processEvents();


            // EVALUATE THE MODEL
            this->evaluateModel(theGradientType);


            // TELL USER WE'RE DONE
            QDateTime finishTime = QDateTime::currentDateTime();
            double numDays = startTime.daysTo(finishTime);
            double numMilliSecs = startTime.time().msecsTo(finishTime.time());
            double numSecs = numDays * 86400.0 + numMilliSecs / 1000.0;
            if (theOutputLevel == RObject::Maximum) {
                //qDebug() << "The analysis in" << this->objectName() << "completed in" << numSecs << "seconds";
            }


            // SET THE 'ANALYZED' FLAG
            isAnalyzed = true;
        }
        else {

            runAnalysis(theGradientType);
        }
//    }
}


bool RModel::contains(RParameter *value)
{
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    bool containsFlag = theAllParametersList.contains(value);

    if (!containsFlag) {
        // Also check if the input RConstants that carry responses from downstream models depend on the passed RParameter (value)
        QList<RConstant *> contList = getConstantList();
        for (int i = 0; i < contList.count(); i++) {
            QList<RParameter *> upstreamParameterList = contList[i]->getUpstreamParameterList();
            if (upstreamParameterList.isEmpty()) {
                continue;
            } else {
                if (upstreamParameterList.contains(value)) {
                    containsFlag = true;
                }
            }
        }
    }

    return containsFlag;
}


int RModel::setResponsesThatFlowUpstream()
{
    return 0;
}


int RModel::runAnalysis(RGradientType theGradientType)
{
    // Checking if all pointer properties are filled out
//    int status = checkProperties();
//    if (status < 0) {
//        return -1;
//    }

    int result = 0;


    QList<RResponse *> inputResponseList = getResponseList();

    for (int i = 0; i < inputResponseList.count(); i++) {
        if (!inputResponseList[i]->isAnalyzed()) {
            RModel *theModel = qobject_cast<RModel *>(inputResponseList[i]->getModel());


            if (!theModel) {
                qCritical() << "Error: Response" << inputResponseList[i]->objectName() << "is not associated with any model.";
                return -1;
            }


            if (!isOrchestratingModel) {
                //qCritical() << "Starting analysis at" << theModel->objectName();
                result = theModel->runAnalysis(theGradientType);
            }

#ifdef NETWORKS
           RNetworkModel* theNetworkModel = qobject_cast<RNetworkModel*>(theModel);
           if (theNetworkModel){
               theNetworkModel->getRequests();
           }
#endif
            if (result < 0) {
                qCritical() << "Error in model: Could not run the analysis in the model" << theModel->objectName() << ".";
                return result;
            }
        }
    }


    //UNCOMMENTING BELOW WILL CRASH RTS IF AN UPSTREAM MODEL IS TAKING INPUT FROM A DOWN STREAM MODEL THAT IS NOT IMMEDIATELY DOWNSTREAM OF IT
    if (theGradientType >= RGradientType::DDM)
    {
        theDDMMap.clear();
        theD2DMMap.clear();
        theD3DMMap.clear();
    }


    if (!isAnalyzed) {


        // START TIMER
        QDateTime startTime = QDateTime::currentDateTime();


        // TELL USER WE'RE STARTING
        if (theOutputLevel == RObject::Maximum) {
            // qDebug() << "The analysis in" << this->objectName() << "started";
        }


        // KEEP GUI RESPONSIVE
        QCoreApplication::processEvents();


        // RUN THE MODEL
        result = evaluateModel(theGradientType);


        // TELL USER WE'RE DONE
        QDateTime finishTime = QDateTime::currentDateTime();
        double numDays = startTime.daysTo(finishTime);
        double numMilliSecs = startTime.time().msecsTo(finishTime.time());
        double numSecs = numDays * 86400.0 + numMilliSecs / 1000.0;
        if (theOutputLevel == RObject::Maximum) {
            // qDebug() << "The analysis in" << this->objectName() << "completed in" << numSecs << "seconds";
        }

    }
    isAnalyzed = true;


    if (result < 0) {
        if (result > -9)
        {
            qCritical() << "Error: Could not evaluate the model" << objectName() << ".";
        }
        if (result == -10)
        {
            qCritical() << "Error: Could not evaluate the DDM in model" << objectName() << ".";
        }
        return result;
    }


    //The DDM Parameters List
    // DDM
    if ( theGradientType >= RGradientType::DDM  && !isOrchestratingModel)
    {
        //The if statement below needs to be commented out with the new createMesh scheme where the mesh is created within the model... hence you have to run evaluate model first before you get the DDM list
        //if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
        if (!ok) {
            qCritical() << "Error: Could not get the parameter list of the model" << objectName() << ".";
            return -1;
        }
        //}


        if (result == 0) {
            // If the return value of evaluateModel is 1, it mean that the model has the DDM implementation
            // If the return value of evaluateModel is 0, it mean that the model does NOT have the DDM implementation and finite difference should be perfoemed
            // **terje result = evaluateModelGradient();
            if (result < 0) {
                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << ".";
                return -1;
            }
        }



        // Establish theDependenceMap once and for all; that is, this will be run only at first evaluation of the model
        if (theDependenceMap.isEmpty()) { //????? Is this a good condition?
            // Iterate on the inputResponseList
            for (int i = 0; i < inputResponseList.count(); i++) {
                QMap<RParameter *, double> theGradientMap = inputResponseList[i]->getGradientMap();
                QList<RParameter *> dependenceToThisResponseList = theGradientMap.uniqueKeys();//????

                //                if (theGradientMap.empty())
                //                {

                //                    return 0;
                //                }

                // Find the index of this input response in theAllParametersList
                int index = theAllParametersList.indexOf(inputResponseList[i]);

                // Iterate on the RParameters that affect this input response, namely dependenceToThisResponseList, and add the index of this response to the map of that parameter
                for (int j = 0; j < dependenceToThisResponseList.count(); j++) {
                    theDependenceMap.insertMulti(dependenceToThisResponseList[j], index);
                }
            }

            // Iterate on the list of direct input parameters depending on which type are being differentiated for (DV/RV/C)
            QList<RParameter *> inputParameterList;

            QList<RRandomVariable *> tempParameterList = getRandomVariableList();
            for (int i = 0; i < tempParameterList.count(); i++) {
                inputParameterList << tempParameterList[i];
            }

            QList<RDecisionVariable *> tempParameterList2 = getDecisionVariableList();
            for (int i = 0; i < tempParameterList2.count(); i++) {
                inputParameterList << tempParameterList2[i];
            }
            QList<RConstant *> tempParameterList3 = getConstantList();
            for (int i = 0; i < tempParameterList3.count(); i++) {
                inputParameterList << tempParameterList3[i];
            }


            // Add the -1 to the map of direct input parameters to indicate they are direct input
            for (int i = 0; i < inputParameterList.count(); i++) {
                theDependenceMap.insertMulti(inputParameterList[i], -1);
            }
        }

        // Get a list of output responses in order to begin evaluation of their gradient
        QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

        // Export a list of RV/DV/C that affect this model from theDependenceMap
        QList<RParameter *> dependenceParameterList = theDependenceMap.uniqueKeys();

        // Iterate on the outputResponseList
        for (int i = 0; i < outputResponseList.count(); i++) {
            RResponse *outputResponse = outputResponseList[i];

            // Declaring theGradientMap for this outputResponse
            QMap<RParameter *, double> theGradientMap;

            // Extract the map of DDM for this response from theDDMMap (This is basically the gradient of this response to model inputs, calculated in the sub-class)
            // Note: A QList of these gradients are exported, since the outputResponse can be an RLocationResponse with 3 gradients
            QList<QMap<RParameter *, double> > outputResponseDDMMapList = theDDMMap.values(outputResponse);

            // Iterate on the outputResponseDDMMapList to get each of the gradient vectors (maps) of thsi response (E.g., if this is an RLocationResponse, it has 3 gradients (maps))
            for (int j = 0; j < outputResponseDDMMapList.count(); j++) {
                QMap<RParameter *, double> outputResponseDDMMap = outputResponseDDMMapList[j];

                // Iterate on the list of parameters that this response should be differentiated with respect to, namely dependenceParameterList
                for (int k = 0; k < dependenceParameterList.count(); k++) {
                    RParameter *dependenceParameter = dependenceParameterList[k];

                    // Exporting the index list of input responses that depend on this dependenceParameter (RV/DV/C)
                    QList<int> indexList = theDependenceMap.values(dependenceParameter);

                    // Declare the double that stored the d(outputResponse) / d(dependenceParameter)
                    double diff = 0.0;

                    for (int l = 0; l < indexList.count(); l++) {
                        int index = indexList[l];
                        if (index == -1) {
                            // Means that the model directly depends to the dependenceParameter
                            diff += outputResponseDDMMap.value(dependenceParameter, 0.0);
                        } else {
                            // Get the pointer to the input response with the index "index" in theAllParametersList
                            RResponse *inputResponse = qobject_cast<RResponse *>(theAllParametersList[index]);
                            if (!inputResponse) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << ". The parameter" << theAllParametersList[index]->objectName() << "in not a response.";
                                return -1;
                            }

                            // Export the gradient elements of the inputResponse with respect to the dependenceParameter (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QMap<RParameter *, double> inputResponseGradientMap = inputResponse->getGradientMap();
                            QList<double> inputResponseGradientdoubleList = inputResponseGradientMap.values(dependenceParameter);

                            // Export the DDM elements of the outputResponse with respect to the inputResponse (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QList<double> DDMdoubleList = outputResponseDDMMap.values(inputResponse);

                            int inputResponseGradientdoubleCount = inputResponseGradientdoubleList.count();
                            if (DDMdoubleList.count() != inputResponseGradientdoubleCount) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << " due to inconsistency between the nummber of DDMs of the output response" << outputResponse->objectName() << "with respect to input response" << inputResponse->objectName() << "and the number of derivatives of" << inputResponse->objectName() << "with respect to" << dependenceParameter->objectName() << ".";
                                return -1;
                            }

                            // Add up the product of these 2 double lists:  d(outputResponse) / d(dependenceParameter) = [d(outputResponse) / d(inputResponse)] * [d(inputResponse) / d(dependenceParameter)]
                            for (int m = 0; m < inputResponseGradientdoubleCount; m++) {
                                // "inputResponseGradientdoubleCount - 1 - m" is used in the following formula because the order of saving, e.g., lat, lng, and alt in an RLocationResponse, in theGradientMap has been reversed. That's because the most recently written variable is retrived first using QMap::values(...).
                                diff += DDMdoubleList[m] * inputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
                            }
                        }
                    }
                    // Assign this element of theGradientMap
                    theGradientMap.insertMulti(dependenceParameter, diff);
                }
            }
            // Submit theGradientMap to the outputResponse
            outputResponse->setGradientMap(theGradientMap);
        }
    }

    //Second order differentiation
    if (theGradientType >= D2DM  && !isOrchestratingModel)
    {

        //The all parameters list and dependency map were established above

        // Get a list of output responses in order to begin evaluation of their gradient
        QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

        // Export a list of RV/DV/C that affect this model from theDependenceMap
        QList<RParameter *> dependenceParameterList = theDependenceMap.uniqueKeys();

        // Iterate on the outputResponseList
        for (int i = 0; i < outputResponseList.count(); i++)
        {
            RResponse *outputResponse = outputResponseList[i];

            // Declaring theGradientMap for this outputResponse
            QMap<RParameter *, double> theSOGradientMap;

            // Extract the map of DDM for this response from theDDMMap (This is basically the gradient of this response to model inputs, calculated in the sub-class)
            // Note: A QList of these gradients are exported, since the outputResponse can be an RLocationResponse with 3 gradients
            QList<QMap<RParameter *, double> > secondOrderOutputResponseDDMMapList = theD2DMMap.values(outputResponse);

            QList<QMap<RParameter *, double> > firstOrderOutputResponseDDMMapList = theDDMMap.values(outputResponse);

            //            if(secondOrderOutputResponseDDMMapList.size() != firstOrderOutputResponseDDMMapList.size())
            //            {
            //                qCritical()<<"Error, the DDM gradients for the second order calculation must be equal";
            //            }

            // Iterate on the outputResponseDDMMapList to get each of the gradient vectors (maps) of thsi response (E.g., if this is an RLocationResponse, it has 3 gradients (maps))
            for (int j = 0; j < secondOrderOutputResponseDDMMapList.count(); j++)
            {
                QMap<RParameter *, double> firstOrderOutputResponseDDMMap = firstOrderOutputResponseDDMMapList[j];

                QMap<RParameter *, double> secondOrderOutputResponseDDMMap = secondOrderOutputResponseDDMMapList[j];

                // Iterate on the list of parameters that this response should be differentiated with respect to, namely dependenceParameterList
                for (int k = 0; k < dependenceParameterList.count(); k++)
                {

                    RParameter *dependenceParameter = dependenceParameterList[k];

                    // Exporting the index list of input responses that depend on this dependenceParameter (RV/DV/C)
                    QList<int> indexList = theDependenceMap.values(dependenceParameter);

                    // Declare the double that stored the d2(outputResponse) / d(dependenceParameter)2

                    double diff = 0.0;

                    for (int l = 0; l < indexList.count(); l++)
                    {
                        int index = indexList[l];

                        if (index == -1) {
                            // Means that the model directly depends to the dependenceParameter
                            diff += secondOrderOutputResponseDDMMap.value(dependenceParameter, 0.0);
                        }

                        else {
                            // Get the pointer to the input response with the index "index" in theAllParametersList
                            RResponse *inputResponse = qobject_cast<RResponse *>(theAllParametersList[index]);

                            if (!inputResponse) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << ". The parameter" << theAllParametersList[index]->objectName() << "in not a response.";
                                return -1;
                            }

                            // Export the gradient elements of the inputResponse with respect to the dependenceParameter (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QMap<RParameter *, double> firstOrderInputResponseGradientMap = inputResponse->getGradientMap();
                            QMap<RParameter *, double> secondOrderInputResponseGradientMap = inputResponse->getSecondOrderGradientMap();

                            QList<double> firstOrderinputResponseGradientdoubleList = firstOrderInputResponseGradientMap.values(dependenceParameter);
                            QList<double> secondOrderinputResponseGradientdoubleList = secondOrderInputResponseGradientMap.values(dependenceParameter);

                            // Export the DDM elements of the outputResponse with respect to the inputResponse (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QList<double> DDMdoubleList = firstOrderOutputResponseDDMMap.values(inputResponse);
                            QList<double> D2DMdoubleList = secondOrderOutputResponseDDMMap.values(inputResponse);

                            int inputResponseGradientdoubleCount = firstOrderinputResponseGradientdoubleList.count();
                            if (DDMdoubleList.count() != inputResponseGradientdoubleCount) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << " due to inconsistency between the nummber of DDMs of the output response" << outputResponse->objectName() << "with respect to input response" << inputResponse->objectName() << "and the number of derivatives of" << inputResponse->objectName() << "with respect to" << dependenceParameter->objectName() << ".";
                                return -1;
                            }

                            // Add up the product of these 2 double lists:  d(outputResponse) / d(dependenceParameter) = [d(outputResponse) / d(inputResponse)] * [d(inputResponse) / d(dependenceParameter)]
                            for (int m = 0; m < inputResponseGradientdoubleCount; m++)
                            {

                                // "inputResponseGradientdoubleCount - 1 - m" is used in the following formula because the order of saving, e.g., lat, lng, and alt in an RLocationResponse, in theGradientMap has been reversed. That's because the most recently written variable is retrived first using QMap::values(...).
                                diff += D2DMdoubleList[m] * firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m]*firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
                                diff += DDMdoubleList[m] * secondOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
                            }
                        }
                    }
                    // Assign this element of theGradientMap
                    theSOGradientMap.insertMulti(dependenceParameter, diff);
                }
            }
            // Submit theGradientMap to the outputResponse
            outputResponse->setSecondOrderGradientMap(theSOGradientMap);
        }
    }

    //Second order differentiation
    if ( theGradientType  >= D3DM && !isOrchestratingModel)
    {

        //The all parameters list and dependency map were established above

        // Get a list of output responses in order to begin evaluation of their gradient
        QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

        // Export a list of RV/DV/C that affect this model from theDependenceMap
        QList<RParameter *> dependenceParameterList = theDependenceMap.uniqueKeys();

        // Iterate on the outputResponseList
        for (int i = 0; i < outputResponseList.count(); i++)
        {
            RResponse *outputResponse = outputResponseList[i];

            // Declaring theGradientMap for this outputResponse
            QMap<RParameter *, double> theTOGradientMap;

            // Extract the map of DDM for this response from theDDMMap (This is basically the gradient of this response to model inputs, calculated in the sub-class)
            // Note: A QList of these gradients are exported, since the outputResponse can be an RLocationResponse with 3 gradients

            QList<QMap<RParameter *, double> > thirdOrderOutputResponseDDMMapList = theD3DMMap.values(outputResponse);

            QList<QMap<RParameter *, double> > secondOrderOutputResponseDDMMapList = theD2DMMap.values(outputResponse);

            QList<QMap<RParameter *, double> > firstOrderOutputResponseDDMMapList = theDDMMap.values(outputResponse);

            //            if(secondOrderOutputResponseDDMMapList.size() != firstOrderOutputResponseDDMMapList.size())
            //            {
            //                qCritical()<<"Error, the DDM gradients for the second order calculation must be equal";
            //            }

            // Iterate on the outputResponseDDMMapList to get each of the gradient vectors (maps) of thsi response (E.g., if this is an RLocationResponse, it has 3 gradients (maps))
            for (int j = 0; j < thirdOrderOutputResponseDDMMapList.count(); j++)
            {
                QMap<RParameter *, double> firstOrderOutputResponseDDMMap = firstOrderOutputResponseDDMMapList[j];

                QMap<RParameter *, double> secondOrderOutputResponseDDMMap = secondOrderOutputResponseDDMMapList[j];

                QMap<RParameter *, double> thirdOrderOutputResponseDDMMap = thirdOrderOutputResponseDDMMapList[j];

                // Iterate on the list of parameters that this response should be differentiated with respect to, namely dependenceParameterList
                for (int k = 0; k < dependenceParameterList.count(); k++)
                {

                    RParameter *dependenceParameter = dependenceParameterList[k];

                    // Exporting the index list of input responses that depend on this dependenceParameter (RV/DV/C)
                    QList<int> indexList = theDependenceMap.values(dependenceParameter);

                    // Declare the double that stored the d2(outputResponse) / d(dependenceParameter)2

                    double diff = 0.0;

                    for (int l = 0; l < indexList.count(); l++)
                    {
                        int index = indexList[l];

                        if (index == -1) {
                            // Means that the model directly depends to the dependenceParameter
                            diff += thirdOrderOutputResponseDDMMap.value(dependenceParameter, 0.0);
                        }

                        else {
                            // Get the pointer to the input response with the index "index" in theAllParametersList
                            RResponse *inputResponse = qobject_cast<RResponse *>(theAllParametersList[index]);

                            if (!inputResponse) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << ". The parameter" << theAllParametersList[index]->objectName() << "in not a response.";
                                return -1;
                            }

                            // Export the gradient elements of the inputResponse with respect to the dependenceParameter (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QMap<RParameter *, double> firstOrderInputResponseGradientMap = inputResponse->getGradientMap();
                            QMap<RParameter *, double> secondOrderInputResponseGradientMap = inputResponse->getSecondOrderGradientMap();
                            QMap<RParameter *, double> thirdOrderInputResponseGradientMap = inputResponse->getThirdOrderGradientMap();

                            QList<double> firstOrderinputResponseGradientdoubleList = firstOrderInputResponseGradientMap.values(dependenceParameter);
                            QList<double> secondOrderinputResponseGradientdoubleList = secondOrderInputResponseGradientMap.values(dependenceParameter);
                            QList<double> thirdOrderinputResponseGradientdoubleList = thirdOrderInputResponseGradientMap.values(dependenceParameter);

                            // Export the DDM elements of the outputResponse with respect to the inputResponse (If the inputResponse is an RLocationResponse, 3 doubles are returned.)
                            QList<double> DDMdoubleList = firstOrderOutputResponseDDMMap.values(inputResponse);
                            QList<double> D2DMdoubleList = secondOrderOutputResponseDDMMap.values(inputResponse);
                            QList<double> D3DMdoubleList = thirdOrderOutputResponseDDMMap.values(inputResponse);

                            int inputResponseGradientdoubleCount = firstOrderinputResponseGradientdoubleList.count();
                            if (DDMdoubleList.count() != inputResponseGradientdoubleCount) {
                                qCritical() << "Error: Could not evaluate the gradient of the model" << objectName() << " due to inconsistency between the nummber of DDMs of the output response" << outputResponse->objectName() << "with respect to input response" << inputResponse->objectName() << "and the number of derivatives of" << inputResponse->objectName() << "with respect to" << dependenceParameter->objectName() << ".";
                                return -1;
                            }

                            // Do the third order DDM Calculation
                            for (int m = 0; m < inputResponseGradientdoubleCount; m++)
                            {
                                // "inputResponseGradientdoubleCount - 1 - m" is used in the following formula because the order of saving, e.g., lat, lng, and alt in an RLocationResponse, in theGradientMap has been reversed. That's because the most recently written variable is retrived first using QMap::values(...).
                                diff += D3DMdoubleList[m]* firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m]*firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m]*firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
                                diff += 3.0*D2DMdoubleList[m] *firstOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m]*secondOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m];
                                diff += DDMdoubleList[m] * thirdOrderinputResponseGradientdoubleList[inputResponseGradientdoubleCount - 1 - m] ;
                            }
                        }
                    }
                    // Assign this element of theGradientMap
                    theTOGradientMap.insertMulti(dependenceParameter, diff);
                }
            }
            // Submit theGradientMap to the outputResponse
            outputResponse->setThirdOrderGradientMap(theTOGradientMap);
        }
    }

    return 0;
}


QList<RRandomVariable *> RModel::getRandomVariableList()
{
    QList<RRandomVariable *> randomVariableList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RRandomVariable *randomVariable = qobject_cast<RRandomVariable *>(parameterList[i]);
        if (randomVariable) {
            randomVariableList.append(randomVariable);
        }
    }
    return randomVariableList;
}


QList<RDecisionVariable *> RModel::getDecisionVariableList()
{
    QList<RDecisionVariable *> decisionVariableList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RDecisionVariable *decisionVariable = qobject_cast<RDecisionVariable *>(parameterList[i]);
        if (decisionVariable) {
            decisionVariableList.append(decisionVariable);
        }

        //        RContinuousDecisionVariable *decisionVariable2 = qobject_cast<RContinuousDecisionVariable *>(parameterList[i]);
        //        if (decisionVariable2) {
        //            decisionVariableList.append(decisionVariable2);
        //        }
    }
    return decisionVariableList;
}


QList<RConstant *> RModel::getConstantList()
{
    QList<RConstant *> constantList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RConstant *constant = qobject_cast<RConstant *>(parameterList[i]);
        if (constant) {
            constantList.append(constant);
        }
    }
    return constantList;
}


QList<RResponse *> RModel::getResponseList()
{
    QList<RResponse *> responseList;
    if (theAllParametersList.isEmpty()) {
        bool ok;
        getAllParametersList(&ok);
    }
    QList<RParameter *> parameterList = theAllParametersList;
    for (int i = 0; i < parameterList.count(); i++) {
        RResponse *response = qobject_cast<RResponse *>(parameterList[i]);
        if (response) {
            responseList.append(response);
        }
    }
    return responseList;
}


void RModel::setResponseAnalyzed(bool analyzed)
{
    QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();
    for (int i = 0; i < outputResponseList.count(); i++) {
        outputResponseList[i]->setAnalyzed(analyzed);
    }
}


QList<RParameter *> RModel::getAllParametersList(bool *ok)
{
    theAllParametersList.clear();

    // Creating a list of parameters to return at the end
    QList<RParameter *> theParameterList;

    // Getting the list of RResponses that are output of this model
    QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();

    // Looping over QProperties
    for (int i = 0; i < this->metaObject()->propertyCount(); i++) {
        // Getting the meta property
        QMetaProperty metaProperty = this->metaObject()->property(i);

        // Getting the tpe of the meta property
        QVariant::Type type = metaProperty.type();


        // Getting the name of the property
        const char * charName = metaProperty.name();


        // Stage1: Populating the theParameterList with individual parameters, which are represented by QProperties
        // Checking if the type of the property is "QObject *"
        if (type == QMetaType::QObjectStar) {
            // Getting the vaue of the property, which is a "QObject *"
            QObject *propertyObject = this->property(charName).value<QObject *>();

            // Down-casting a pointer with the type "RParameter" to the "QObject *"
            RParameter *parameter = qobject_cast<RParameter *>(propertyObject);

            // If the casting succeeds, it mean that the type of this pointer is RParameter. Proceeding to add it to the list.
            if (parameter) {
                // If the parameter is not already in the list ...
                if (!theParameterList.contains(parameter)) {
                    // Down-casting a pointer with the type "RResponse"
                    RResponse *response = qobject_cast<RResponse *>(parameter);

                    // If the type of this parameter is RResponse, it should be checked hat this RResponse is not an OUTPUT to this model.
                    // Thus, if the casting to RResponse succeeds, the "outputResponseList" is searched for this RResponse.
                    // If this RResponse was not found in "outputResponseList", OR this parameter is not an RResponse at all ("response" is NULL), then this RParameter pointer is added to the parmeter list.
                    if (((response) && (!outputResponseList.contains(response))) || (!response)) {
                        theParameterList << parameter;
                    }
                }
            }
            continue;
        }

        // Stage2: Appending the lists of unlimited number of parameters to the "parameterList".
        // The type of the QProperty representing the unlimited list od parameters is QString.
        // So, if the type of the QProperty is QString, it is considered to be added to theParameterList
        // HOWEVER, it should be noted that there are other QProperties such as "type" and "objectName" that are QString and do not contain any parameter list.
        // So, this naming convention must be kept as a rule:
        // If a QProperty of type QString is to reperesent a parameter list, its name should end with the word "List" (case-sensitive).
        if (type == QMetaType::QString) {
            //QString methodName(charName);
            //methodName.replace(0, 1, methodName.at(0).toUpper());
            //methodName = "get" + methodName;
            ////const char * methodCharName = qPrintable(methodName);
            //QByteArray byteArrayName = methodName.toLatin1();
            //const char * methodCharName = byteArrayName.data();
            //RParameterList parameterList;
            //bool ok = QMetaObject::invokeMethod(this, methodCharName, Q_RETURN_ARG(RParameterList, parameterList));

            // Check if the property name contains the word "List"
            if (QString(charName).contains("List")) {

                // Producing a list of RParameters form the value of the QProperty, which is a QString
                QList<QPointer<RParameter> > parameterList = stringToParameterList(this->property(charName).toString());

                // Lopping over the produced list
                for (int j = 0; j < parameterList.count(); j++) {
                    RParameter *parameter = parameterList[j];

                    // If the parameter is not already included in "theParameterList", then add it.
                    if (!theParameterList.contains(parameter)) {
                        theParameterList << parameter;
                    }
                }
            }
            continue;
        }
    }


    // Now, all the QProperties are looped over.

    //    //Get the stuff that was added in RDomain
    //    auto theDomainList = theDomain->getDDMParameterList();
    //    theParameterList.append(theDomainList);

    // Sorting the generated liest
    theDomain->sort(&theParameterList);

    // Assigning to the data member
    theAllParametersList = theParameterList;

    *ok = true;

    // Add the parameters that were auto-created within this model
    for (int i=0; i<theAutoParametersList.size(); i++) {
        theAllParametersList << theAutoParametersList.at(i);
    }


    // Returning the generated list
    return theAllParametersList;
}


int RModel::evaluateModelGradient(RObject::RParameterType parameterType)
{
    // IMPELEMENT FINITE DIFFERENCE HERE

    int result = 0;

    theDDMMap.clear();

    // HOW TO GET THE PERTURBATION FACTOR?????????????????????
    double perturbationFactor = 1000.0;
    //perturbationFactor = property("PerturbationFactor").toDouble();

    QList<RResponse *> outputResponseList = this->findChildren<RResponse *>();
    // Backing up the response values to return to them after the finite difference analysis
    for (int i = 0; i < outputResponseList.count(); i++) {
        outputResponseList[i]->backup();
    }

    // NOTE: IT IS NOT NECESSARY TO DO THE FINITE DIFFERENCE WITH RESPECT TO ALL INPUT PARAMETERS; DIFERENTIATING WITH RESPECT TO  DV/RV/C (DEPNEDING ON THE parameterType) AND RESPONSES IS SUFFICIENT.
    QList<RParameter *> parameterList;
    if (parameterType == RObject::RandomVariable) {
        QList<RRandomVariable *> randomVariableList = getRandomVariableList();
        for (int i = 0; i < randomVariableList.count(); i++) {
            parameterList << randomVariableList[i];
        }
    } else if (parameterType == RObject::DecisionVariable) {
        QList<RDecisionVariable *> decisionVariableList = getDecisionVariableList();
        for (int i = 0; i < decisionVariableList.count(); i++) {
            parameterList << decisionVariableList[i];
        }
    } else if (parameterType == RObject::Constant) {
        QList<RConstant *> constantList = getConstantList();
        for (int i = 0; i < constantList.count(); i++) {
            parameterList << constantList[i];
        }
    }
    QList<RResponse *> inputResponseList = getResponseList();
    for (int i = 0; i < inputResponseList.count(); i++) {
        parameterList << inputResponseList[i];
    }

    int count = parameterList.count();

    // Iterating on input parameters to evaluate the partial derivative of the outpur responses with respect to them
    for (int i = 0; i < count; i++) {
        RParameter *parameter = parameterList[i];

        RResponse *inputResponse = qobject_cast<RResponse *>(parameter);
        QVector<double> valueVector;
        int parameterInputCount;
        if (!inputResponse) {
            parameterInputCount = 1;
        } else {
            valueVector = inputResponse->getValueVector();
            parameterInputCount = valueVector.count();
            inputResponse->backup();
        }

        for (int j = 0; j < parameterInputCount; j++) {
            // Taking a backup from the current value of the parameter
            double currentValueBackup;
            if (!inputResponse) {
                currentValueBackup = parameter->getCurrentValue();
            } else {
                currentValueBackup = valueVector[j];
            }

            double h;
            if ((parameterType == RObject::RandomVariable) && (!inputResponse)) {
                // Getting the standard deviation of the random variable
                RRandomVariable *randomVariable = qobject_cast<RRandomVariable *>(parameter);
                double standardDeviation = randomVariable->getStandardDeviationValue();
                if (standardDeviation == 0) {
                    qCritical() << "WARNING: The standard deviation of the random variable" << randomVariable->objectName() << " is 0. Rt is perturbing the random variable by (1.0/perturbation factor) in the finite difference analysis.";
                    standardDeviation = 1.0;
                }

                // Perturbing the current value of the random variable
                h = standardDeviation / perturbationFactor;
            } else {
                if (currentValueBackup == 0.0) {
                    h = 0.001;
                    //qCritical() << "WARNING: Parameter is zero, selecting" << h << "as the perturbation in finite difference analysis.";
                } else {
                    h = currentValueBackup / perturbationFactor;
                }
            }

            // Perturb the value of the parameter
            double purterbedValue = currentValueBackup + h;
            if (!inputResponse) {
                parameter->setCurrentValue(purterbedValue);
            } else {
                QVector<double> perturbedVector = valueVector;
                perturbedVector[j] = purterbedValue;
                inputResponse->setValueVector(perturbedVector);
            }

            // Evaluate the model
            int result = evaluateModel(RGradientType::NONE);
            isAnalyzed = true;
            if (result < 0) {
                qCritical() << "Error: Could not evaluate the model" << objectName() << " while calculating its partial derivative with respect to the parameter" << parameter->objectName() << " using finite difference.";
            }

            // Iterate on output responses to calculate the gradient
            for (int k = 0; k < outputResponseList.count(); k++) {
                RResponse *outputResponse = outputResponseList[k];
                QVector<double> backupVector = outputResponse->getBackupVector();
                QVector<double> valueVector = outputResponse->getValueVector();
                int backupVectorCount = backupVector.count();

                // Establishing the QMap for this response
                if ((i == 0) && (j == 0)) {
                    for (int l = 0; l < backupVectorCount; l++) {
                        QMap<RParameter *, double> gradientMap;
                        theDDMMap.insertMulti(outputResponse, gradientMap);
                    }
                }

                // Calculating and assigning the calculated gradient element
                QList<QMap<RParameter *, double> > gradientMapList = theDDMMap.values(outputResponse);
                theDDMMap.remove(outputResponse);
                for (int l = 0; l < backupVectorCount; l++) {
                    // Calculating the partial derivative value
                    double gradElement = (valueVector[l] - backupVector[l]) / h;

                    //qDebug() << "d(" << outputResponse->objectName() << ") / d(" << parameter->objectName() << ") = " << gradElement;

                    // Assigning
                    gradientMapList[backupVectorCount - 1 - l].insertMulti(parameter, gradElement);
                    theDDMMap.insertMulti(outputResponse, gradientMapList[backupVectorCount - 1 - l]);
                }
            }

            // Restoring the current value of the input parameter
            if (!inputResponse) {
                parameter->setCurrentValue(currentValueBackup);
            } else {
                inputResponse->restore();
            }

            // Restoring the response values to the original values backed up before gradient analysis
            for (int k = 0; k < outputResponseList.count(); k++) {
                outputResponseList[k]->restore();
            }
        }
    }
    // Now, all input parameters are looped over.


    //qCritical() << "Warning: The model" << objectName() << "does not support DDM. Finite difference is performed on this model.";

    return 0;
}


void RModel::clearDDMMaps()
{
    theDDMMap.clear();
    theDependenceMap.clear();
}


void RModel::deleteOutputFiles()
{
    QList<RFileResponse *> responseList = findChildren<RFileResponse *>();
    for (int i = 0; i < responseList.count(); i++) {
        QString filePath = responseList[i]->getResponseFile();
        QFile file(filePath);
        file.remove();
    }
}


void RModel::initiatePtocess(QString workingFilePath)
{
    QString workingPath = RDomain::getAbsoluteFolderPath(workingFilePath);
    bool workingPathIsSet = QDir::setCurrent(workingPath);

    // Instantiating the QProcess
    if (!theProcess) {
        theProcess = new QProcess(this);
    }

    // Checking if the QProcess is not running
    if (theProcess->state() == QProcess::NotRunning) {
        // Setting system environment variables to QProcess
        QStringList environmentList = QProcess::systemEnvironment();
        theProcess->setEnvironment(environmentList);

        // Merging the standard and error channels of the QProcess
        theProcess->setProcessChannelMode(QProcess::MergedChannels);

        // Setting the working directory of the QProcess to the directory of the main input file
        theProcess->setWorkingDirectory(workingPath);

        // Connecting the signal of finished to the slot of onProcessFinished to check if the process has exited normally or crashed
        bool ok = connect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(onProcessFinished(int, QProcess::ExitStatus)));
        //connect(theProcess, SIGNAL(started()), this, SLOT(processStarted()));
    }

    // Connecting the signal "readyReadStandardOutput" of the QProcess to the slot "showOutput", which displays the output in the output pane
    bool ok = connect(theProcess, SIGNAL(readyReadStandardOutput()), this, SLOT(showOutput()));
}


QProcess * RModel::getProcess()
{
    return theProcess;
}


void RModel::showOutput()
{
    QByteArray outputBytes = theProcess->readAllStandardOutput();
    if (theOutputLevel >= RObject::Medium) {
        QStringList lines = QString(outputBytes).split("\n");
        foreach (QString line, lines) {
            if (line.length() > 0) {
                qDebug() << qPrintable(line);
            }
        }
    }

    //// The follwoing lines are required in the case that the external software should not be closed at the end of the analysis. They are needed to determine that the external software is done with the analysis.
    if (processFinishedAnalyzing) {
        if (outputBytes.contains(finishString)) {
            processFinishedAnalyzing = false;

            emit processFinished();

            // Disconnect the readyReadStandardOutput from this method, because from now on, we need to read responses and we don't want the results of the commands of the RCommandResponse to be shown in the output pane. The signal will be reconnected in the initiateProcess the next time the evaluateFunction is called
            disconnect(theProcess, SIGNAL(readyReadStandardOutput()), this, SLOT(showOutput()));
        }
    }
}


void RModel::eventLoop(bool continuousProcess)
{		
    bool ok;


    // This is the event loop of waiting for the analysis in the external application to be finished
    QEventLoop runEventLoop;

    ok = connect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), &runEventLoop, SLOT(quit()));
    if (continuousProcess) {
        ok = connect(this, SIGNAL(processFinished()), &runEventLoop, SLOT(quit()));
    }

    //QTimer timer;
    //connect(&timer, SIGNAL(timeout()), &runEventLoop, SLOT(quit()));
    //timer.start(7000);

    if (processFinishedAnalyzing) {
        runEventLoop.exec();
    }

    //bool active = timer.isActive();
    //if (!active) {
    //	qCritical() << "Warning: Rt has waited for 7 seconds, but the analysis of the external software is not done yet. Terminating the analysis";
    //}

    ok = disconnect(theProcess, SIGNAL(finished(int, QProcess::ExitStatus)), &runEventLoop, SLOT(quit()));
    if (continuousProcess) {
        ok = disconnect(this, SIGNAL(processFinished()), &runEventLoop, SLOT(quit()));
    }
}


void RModel::onProcessFinished(int exitCode, QProcess::ExitStatus exitStatus)
{
    if (exitStatus == QProcess::CrashExit) {
        qCritical() << "Warning: The external application in the model" << this->objectName() << "has crashed.";
    }
}


void RModel::clearNullPointers(QList<QPointer<RParameter> > *passdedParameterList)
{
    for (int i = 0; i < passdedParameterList->count(); i++) {
        if (!passdedParameterList->value(i)) {
            passdedParameterList->removeAt(i);
            i--;
        }
    }
}


QList<RParameter *> RModel::getPhysicalParameterList()
{
    QList<RParameter *> paramList;
    return paramList;
}


void RModel::reset()
{

}


void RModel::updateHistoryVariables()
{

}


void RModel::resetHistoryVariables()
{

}


int RModel::resetTime()
{
    return 0;
}


